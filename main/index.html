<!DOCTYPE html>
<html>
<head>
<title> ESP32 </title>

<script>



function getFile(event) {
	const input = event.target
  if ('files' in input && input.files.length > 0) {
	  placeFileContent(
      document.getElementById('content-target'),
      input.files[0])
  }
}

function placeFileContent(target, file) {
	readFileContent(file).then(content => {
  	target.value = content;
	const parser = new DOMParser();
	xml = parser.parseFromString(content, "text/xml");
	console.log(xml.getElementsByTagName("path"));
  }).catch(error => console.log(error))
}

function readFileContent(file) {
	const reader = new FileReader()
  return new Promise((resolve, reject) => {
    reader.onload = event => resolve(event.target.result)
    reader.onerror = error => reject(error)
    reader.readAsText(file)
  })
}

function submit_helper(a_t, a_hz, b_t, b_hz) {
    fetch('spin', {
        method: 'post',
        headers: {
            '_wb_a_ticks': a_t, 
			'_wb_a_hz': a_hz, 
            '_wb_b_ticks': b_t,
			'_wb_b_hz': b_hz,
        }
    });
}

function submit() {
	submit_helper(document.getElementById("a_ticks").value,
	    	document.getElementById("a_hz").value,
		    document.getElementById("b_ticks").value,	
		    document.getElementById("b_hz").value)	
}

function send_ccode() {
	const content = document.getElementById("input-ccode").value;
	fetch('http://esp32-1.dyn.wpi.edu/ccode', {
		method: 'post',
		body: content
	}).then(e => {
		const span = document.getElementById("response-back");
		if(e.status == 400) {
			span.style = "color: red";
		} else if(e.status == 500) {
			span.style = "color: #c87c07;"
		} else {
			span.style = "color: green";
		}
		e.text().then(x => span.innerText = x)
	})
	console.log("sending ccode", content);
	return false;
}

function refresh_status() {
	fetch("http://esp32-1.dyn.wpi.edu/status")
		.then(e => e.json())
		.then(e => {
			for(key in e) {
				document.getElementById("status_gen_" + key).innerText = e[key];
			}
			console.log("refreshed");
			refresh_status();
		});
}

function onload() {
	refresh_status();
	setup_canvas();
}

</script>

</head>

<body onload="onload()">

<h1> Whiteboard </h1>

<h2>CCode</h2>

<form onsubmit="return send_ccode()">
	<input style="width: 40%; font-size: 20px" type="text" id="input-ccode"/>
	<input type="submit" value="Run"/>
	<span id="response-back"></span>
</form>


<style>
	.mono {
		font-family: monospace;
	}
	.monospaced span {
		font-family: monospace;
		padding-right: 20px;
		width: 200px;
		display: inline-block;
	}
	.monospaced span.inline {
		width: auto;
		padding-right: 0px;
	}
	body {
		margin: 20px;
	}
	.fixed_width {
		width: 100px;
		display: inline-block;
	}
</style>

<div class="monospaced">
	<h4>Machine Code</h4>
	Machine codes work with the length of the strings.
	There are two spools, A and B.
	<br/>

	<span>m0 [a ticks] [b ticks]</span>Adjusts the position of A and B relative to the current position
	<br/>
	<span>m1 [a ticks] [b ticks]</span>Sets the position of A and B relative to home
	<br/>
	<span>m10</span>Homes both the A and B spools, assuming both are at the hardcoded center of the board.
	<br/>
	<span>m11 [hz]</span> Sets the maximum stepper tick rate in hertz



	<h4>C Code</h4>
	<span>c0 [x] [y]</span>Moves the marker to a specific <span class="inline">[x] [y]</span> position as fast as possible
	<br/>
	<span>c1 [x] [y]</span>Moves the market to a specific <span class="inline">[x] [y]</span> position in a straight line
	<br/>
	<span>c2..9</span>TO BE DETERMINED more complex movements
	<br/>
	<span>c10 ([x] [y])</span>Sets the relative home to the current position, or <span class="inline">[x] [y]</span> if specified
	<br/>
	<span>c11 [home/relative]</span>Makes commands like <span class="inline"">c0</span>
	act relative to home or the relative marker
	<br/>
</div>

<hr>

<div class="mono">
	A Position: <span id="status_gen_a_pos"></span>
	<br/>
	B Position: <span id="status_gen_b_pos"></span>
	<br/>
	Max Feedrate: <span id="status_gen_max_feedrate"></span>
	<br/>
</div>

<script>

let points = [
	[ 300, 300 ],
	[ 200, 100 ],
	[ 200, 500 ],
	[ 250, 300 ]
];


const t_step = 0.01;
let B = (t, i) => (1 - t) * (1 - t) * (1 - t) * points[0][i] + 3 * (1 - t) * (1 - t) * t * points[1][i] + 3 * (1 - t) * t * t * points[2][i] + t * t * t * points[3][i];


function draw_curve(ctx, w, h) {

	
	ctx.fillStyle = "lightblue";

	ctx.fillRect(0, 0, w, h);	

	//ctx.fillStyle = "rgba(0.01,0.01,0.01,0.11)";

	//ctx.fillRect(0, 0, w, h);

	ctx.fillStyle = "green";
	ctx.lineWidth = 4
	for(point of points) {
		ctx.fillRect(point[0] - 10, point[1] - 10, 20, 20)
	}

	let t = 0;
	let x_1 = points[0][0];
	let y_1 = points[0][1]; 
	ctx.beginPath();
	ctx.moveTo(x_1, y_1);
	while(t < 1) {
		t += t_step;
		let x_2 = B(t, 0);
		let y_2 = B(t, 1);
		ctx.lineTo(x_2, y_2);
	}
	ctx.stroke();
}

function setup_canvas() {
	const canvas = document.getElementById("draw");
	const ctx = canvas.getContext("2d");

	let current_point = null; // null = mouse up

	function get_xy(e) {
		const rect = canvas.getBoundingClientRect();
		const x = e.clientX - rect.left;
		const y = e.clientY - rect.top;
		return { x: x, y: y };
	}

	canvas.onmousedown = function(e){
		// find closest point
		const pos = get_xy(e);
		let dist = Infinity;
		for(i in [0, 1, 2, 3]) {
			// hypotenuse distance
			const d = Math.pow(pos.x - points[i][0], 2) + Math.pow(pos.y - points[i][1], 2);
			if(d < 300 && d < dist) {
				dist = d;
				current_point = i;
			}
		}
	}
	canvas.onmouseup = function(e){
		current_point = null;
	}

	canvas.onmousemove = function(e){
		if(current_point == null) return;
		const pos = get_xy(e);
		points[current_point][0] = pos.x;
		points[current_point][1] = pos.y;
		draw_curve(ctx, canvas.width, canvas.height);
		return false;
	}
	draw_curve(ctx, canvas.width, canvas.height);
}
</script>

<div class="curves"></div>
<canvas id="draw" width="1000" height="1000">

</canvas>
</body>


</html>