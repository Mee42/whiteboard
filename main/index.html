<!DOCTYPE html>
<html>
<head>
<title> ESP32 </title>

<script>



function getFile(event) {
	const input = event.target
  if ('files' in input && input.files.length > 0) {
	  placeFileContent(
      document.getElementById('content-target'),
      input.files[0])
  }
}

function placeFileContent(target, file) {
	readFileContent(file).then(content => {
  	target.value = content;
	const parser = new DOMParser();
	xml = parser.parseFromString(content, "text/xml");
	console.log(xml.getElementsByTagName("path"));
  }).catch(error => console.log(error))
}

function readFileContent(file) {
	const reader = new FileReader()
  return new Promise((resolve, reject) => {
    reader.onload = event => resolve(event.target.result)
    reader.onerror = error => reject(error)
    reader.readAsText(file)
  })
}

function send_ccode() {
	const content = document.getElementById("input-ccode").value;
	fetch('http://esp32-1.dyn.wpi.edu/ccode', {
		method: 'post',
		body: content
	}).then(e => {
		const span = document.getElementById("response-back");
		if(e.status == 400) {
			span.style = "color: red";
		} else if(e.status == 500) {
			span.style = "color: #c87c07;"
		} else {
			span.style = "color: green";
		}
		e.text().then(x => span.innerText = x)
	})
	console.log("sending ccode", content);
	return false;
}
let running = false;

function refresh_status() {
	fetch("http://esp32-1.dyn.wpi.edu/status")
		.then(e => e.json())
		.then(e => {
			for(key in e) {
				let d = document.getElementById("status_gen_" + key);
				if(key == "running") {
					d = document.getElementById("running_indicator");
					running = e[key]
					d.innerText = (e[key] ? "Running" : "Idle")
					d.style = "color: " + (e[key] ? "green" : "#8000ff")
				} else if(key == "regs") {
					d.innerText = JSON.stringify(e[key]).substring(1)
					d.innerText = d.innerText.substring(0, d.innerText.length - 1)
				} else {
					d.innerText = e[key];
				}
			}
			console.log("refreshed");
			refresh_status();
		});
}

function onload() {
	refresh_status();
	setup_canvas();
}

</script>

</head>

<body onload="onload()">

<h1> Whiteboard </h1>

<h2>CCode <span id="running_indicator"></span></h2>

<form onsubmit="return send_ccode()">
	<input style="width: 40%; font-size: 20px" type="text" id="input-ccode"/>
	<input type="submit" value="Run"/>
	<span id="response-back"></span>
</form>


<style>
	.mono {
		font-family: monospace;
	}
	.monospaced span {
		font-family: monospace;
		padding-right: 20px;
		width: 200px;
		display: inline-block;
	}
	.monospaced span.inline {
		width: auto;
		padding-right: 0px;
	}
	body {
		margin: 20px;
	}
	.fixed_width {
		width: 100px;
		display: inline-block;
	}
</style>

<div class="monospaced">
	<h4>Machine Code</h4>
	Machine codes work with the length of the strings.
	There are two spools, A and B.
	<br/><br/>

	<span>m0 a[ticks] b[ticks]</span>Adjusts the position of A and B relative to the current position.
	<br/>
	<span>m1 a[ticks] b[ticks]</span>Sets the absolute position of A and B.
	<br/>
	<span>m10</span>Homes both the A and B spools, assuming both are at the hardcoded center of the board.
	<br/>
	<span>m11 s[hz]</span>Sets the maximum stepper tick rate in hertz.


	<h4>C Code</h4>
	Registers <span class="inline">r0..9</span> exist. They are all references off of <span class="inline">(0, 0)</span>.
	<br/><span class="inline"> r0</span> is always <span class="inline">(0, 0)</span>.
	<br/><span class="inline"> r9</span> is always the current carriage position.
	<br/>
	Register can be specified to any command to use that position as the origin for the operation.
	If left out, the "default" register is used (set via <span class="inline">c11</span>)
	<br/><br/>
	<span>c0 x[mm] y[mm] r[reg]</span>Moves the marker to a specific <span class="inline">[x] [y]</span> position as fast as possible
	<br/>
	<span>c1 x[mm] y[mm] r[reg]</span>Moves the market to a specific <span class="inline">[x] [y]</span> position in a straight line
	<br/>
	<span>c2..9</span>TO BE DETERMINED more complex movements
	<br/>
	<span>c10 x[mm] y[mm] r[reg]</span>Sets the specified register to the specified
	<span class="inline">[x] [y]</span> position (relative to 0, 0), unless left out, in which case current position is used.
	<br/>
	<span>c11 r[reg]</span>Sets the current default register.
	<br/>
</div>

<hr>

<div class="mono">
	A Position: <span id="status_gen_a_pos"></span>
	(<span id="status_gen_a_real"></span>)
	<br/>
	B Position: <span id="status_gen_b_pos"></span>
	(<span id="status_gen_b_real"></span>)
	<br/>
	X Position: <span id="status_gen_x_pos"></span>
	<br/>
	Y Position: <span id="status_gen_y_pos"></span>
	<br/>
	Is XY Valid: <span id="status_gen_is_xy_valid"></span>
	<br/>
	Max Feedrate: <span id="status_gen_max_feedrate"></span>
	<br/>
	Default Register: <span id="status_gen_default_reg"></span>
	<br/>
	Registers: <span id="status_gen_regs"></span>
	
	<br/>

</div>

<script>

let points = [
	[ 300, 300 ],
	[ 200, 100 ],
	[ 200, 500 ],
	[ 250, 300 ]
];


const t_step = 0.01;
let B = (t, i) => (1 - t) * (1 - t) * (1 - t) * points[0][i] + 3 * (1 - t) * (1 - t) * t * points[1][i] + 3 * (1 - t) * t * t * points[2][i] + t * t * t * points[3][i];


function draw_curve(ctx, w, h) {

	
	ctx.fillStyle = "lightblue";

	ctx.fillRect(0, 0, w, h);	

	//ctx.fillStyle = "rgba(0.01,0.01,0.01,0.11)";

	//ctx.fillRect(0, 0, w, h);

	ctx.fillStyle = "green";
	ctx.lineWidth = 4
	for(point of points) {
		ctx.fillRect(point[0] - 10, point[1] - 10, 20, 20)
	}

	let t = 0;
	let x_1 = points[0][0];
	let y_1 = points[0][1]; 
	ctx.beginPath();
	ctx.moveTo(x_1, y_1);
	while(t < 1) {
		t += t_step;
		let x_2 = B(t, 0);
		let y_2 = B(t, 1);
		ctx.lineTo(x_2, y_2);
	}
	ctx.stroke();
}

function setup_canvas() {
	const canvas = document.getElementById("draw");
	const ctx = canvas.getContext("2d");

	let current_point = null; // null = mouse up

	function get_xy(e) {
		const rect = canvas.getBoundingClientRect();
		const x = e.clientX - rect.left;
		const y = e.clientY - rect.top;
		return { x: x, y: y };
	}

	canvas.onmousedown = function(e){
		// find closest point
		const pos = get_xy(e);
		let dist = Infinity;
		for(i in [0, 1, 2, 3]) {
			// hypotenuse distance
			const d = Math.pow(pos.x - points[i][0], 2) + Math.pow(pos.y - points[i][1], 2);
			if(d < 300 && d < dist) {
				dist = d;
				current_point = i;
			}
		}
	}
	canvas.onmouseup = function(e){
		current_point = null;
	}

	canvas.onmousemove = function(e){
		if(current_point == null) return;
		const pos = get_xy(e);
		points[current_point][0] = pos.x;
		points[current_point][1] = pos.y;
		draw_curve(ctx, canvas.width, canvas.height);
		return false;
	}
	draw_curve(ctx, canvas.width, canvas.height);
}
</script>

<div class="curves"></div>
<canvas id="draw" width="1000" height="1000">

</canvas>
</body>


</html>